######################################################
## Variables used by the test runs
######################################################

variables:
    EXTRA_DOCKER_RUN_ARGS: "--shm-size=1G --ulimit memlock=-1 --ulimit stack=$$((1024*65536))"
    DATADIR: /raid/dldata

    # the following will be overridden by jobs of the pipeline that actually need to check out the sources
    GIT_STRATEGY: none
    GIT_SUBMODULE_STRATEGY: none

######################################################
## Build steps.
##    DO NOT MODIFY THIS SECTION
######################################################

stages:
    - build deps
    - build builder
    - build base
    - build devel
    - trigger
    - test
    - build docs

before_script:
    - export PYVER=$(echo "${CI_JOB_NAME}" | grep -Eqv "(^|-)py[23]" && echo "" ||
                     echo "${CI_JOB_NAME}" | sed 's/.*py\([0-9]\)\([0-9]\).*/\1.\2/')              && echo "${PYVER}"
    - export PYV=${PYVER/./}                                                                       && echo "${PYV}"
    - export NV_DOCKER_ARGS="curl -s http://localhost:3476/docker/cli?dev=${RUNNER_GPUS//,/+}"     && echo "${NV_DOCKER_ARGS}"
    - export RELEASE_BRANCH_NAME=${CI_COMMIT_REF_NAME%%-devel}                                     && echo "${RELEASE_BRANCH_NAME}"
    - export IMAGE_NAME_PREFIX="${CI_REGISTRY_IMAGE}:${RELEASE_BRANCH_NAME}"                       && echo "${IMAGE_NAME_PREFIX}"
    - export DEPS_IMAGE_NAME="${IMAGE_NAME_PREFIX}-deps"                                           && echo "${DEPS_IMAGE_NAME}"
    - export DEPS_IMAGE_NAME_VERSIONED="${IMAGE_NAME_PREFIX}.${CI_PIPELINE_ID}-deps"               && echo "${DEPS_IMAGE_NAME_VERSIONED}"
    - export BASE_IMAGE_NAME="${IMAGE_NAME_PREFIX}-py${PYVER}-base"                                && echo "${BASE_IMAGE_NAME}"
    - export BASE_IMAGE_NAME_VERSIONED="${BASE_IMAGE_NAME%%-base}.${CI_PIPELINE_ID}"               && echo "${BASE_IMAGE_NAME_VERSIONED}"
    - export BUILD_IMAGE_NAME="${BASE_IMAGE_NAME%%-base}-build"                                    && echo "${BUILD_IMAGE_NAME}"
    - export BUILD_IMAGE_NAME_VERSIONED="${BASE_IMAGE_NAME_VERSIONED}-build"                       && echo "${BUILD_IMAGE_NAME_VERSIONED}"
    - export DEVEL_IMAGE_NAME="${BASE_IMAGE_NAME%%-base}-devel"                                    && echo "${DEVEL_IMAGE_NAME}"
    - export DEVEL_IMAGE_NAME_VERSIONED="${BASE_IMAGE_NAME_VERSIONED}-devel"                       && echo "${DEVEL_IMAGE_NAME_VERSIONED}"
    - export DOCS_IMAGE_NAME="${BASE_IMAGE_NAME_VERSIONED}-docs"                                   && echo "${DOCS_IMAGE_NAME}"
    - export ORIGIN1="${CI_REPOSITORY_URL##*@}"
    - export ORIGIN_SSH=git@${ORIGIN1/\//:}                                                        && echo "${ORIGIN_SSH}"
    - export ORIGIN_HTTPS=https://${ORIGIN1}                                                       && echo "${ORIGIN_HTTPS}"
    - export GIT_SHA=$(git merge-base HEAD upstream/master)                                        && echo "${GIT_SHA}"
    - docker login -u gitlab-ci-token -p "${CI_JOB_TOKEN}" "${CI_REGISTRY}"

dali_deps:
    stage: build deps
    variables:
      GIT_STRATEGY: fetch
      GET_SOURCES_ATTEMPTS: 3
    script:
    # build the manylinux1 deps image
    - docker pull "${DEPS_IMAGE_NAME}" ||
      docker pull "${CI_REGISTRY_IMAGE}:master-deps" || true
    - docker build --pull
                   --cache-from "${DEPS_IMAGE_NAME}"
                   --cache-from "${CI_REGISTRY_IMAGE}:master-deps"
                   -t "${DEPS_IMAGE_NAME}" -t "${DEPS_IMAGE_NAME_VERSIONED}"
                   -f Dockerfile.deps .
    - docker push "${DEPS_IMAGE_NAME}"
    - docker push "${DEPS_IMAGE_NAME_VERSIONED}"

.builder_template: &BUILDER
    stage: build builder
    variables:
      GIT_STRATEGY: fetch
      GIT_SUBMODULE_STRATEGY: recursive
      GET_SOURCES_ATTEMPTS: 3
    script:
    - echo -e "Dockerfile*\n"
              ".git*\n"
              ".dockerignore\n"
              "docs\n"
              "examples\n"
              "qa/*\n"
              "!qa/L0_lint" > .dockerignore
    # build the manylinux1 builder image
    - docker pull "${BUILD_IMAGE_NAME}" ||
      docker pull "${CI_REGISTRY_IMAGE}:master-py${PYVER}-build" || true
    - docker build --pull
                   --cache-from "${BUILD_IMAGE_NAME}"
                   --cache-from "${CI_REGISTRY_IMAGE}:master-py${PYVER}-build"
                   -t "${BUILD_IMAGE_NAME}" -t "${BUILD_IMAGE_NAME_VERSIONED}"
                   --build-arg "PYVER=${PYVER}" --build-arg "PYV=${PYV}"
                   --build-arg "NVIDIA_BUILD_ID=${CI_PIPELINE_ID}"
                   --build-arg "DEPS_IMAGE_NAME=${DEPS_IMAGE_NAME_VERSIONED}" .
    - docker push "${BUILD_IMAGE_NAME}"
    - docker push "${BUILD_IMAGE_NAME_VERSIONED}"
    # copy out wheels as build artifacts
    - export CONTAINER="extract-${CI_JOB_ID}"
    - docker create --name "${CONTAINER}" "${BUILD_IMAGE_NAME_VERSIONED}"
    - docker cp "${CONTAINER}:/wheelhouse/" "wheelhouse/"
    - docker rm -f "${CONTAINER}"
    artifacts:
      name: "${CI_JOB_NAME}"
      paths:
      - wheelhouse/*.whl
      expire_in: 1 month

py27-wheel:
  <<: *BUILDER

py34-wheel:
  <<: *BUILDER

py35-wheel:
  <<: *BUILDER

py36-wheel:
  <<: *BUILDER

#py37-wheel:
#  <<: *BUILDER

.base_template: &BASE
    stage: build base
    variables:
      GIT_STRATEGY: fetch
      GIT_SUBMODULE_STRATEGY: recursive
      GET_SOURCES_ATTEMPTS: 3
    script:
    - echo -e "Dockerfile*\n"
              ".git*\n"
              ".dockerignore\n"
              "qa" > .dockerignore
    # build a dlbase+dali image
    - docker pull "${BUILD_IMAGE_NAME}" || true
    - docker pull "${BASE_IMAGE_NAME}" || true
    - docker build --pull
                   --cache-from "${BUILD_IMAGE_NAME}"
                   --cache-from "${BASE_IMAGE_NAME}"
                   -t "${BASE_IMAGE_NAME}" -t "${BASE_IMAGE_NAME_VERSIONED}"
                   --build-arg "BUILD_IMAGE_NAME=${BUILD_IMAGE_NAME_VERSIONED}"
                   --build-arg "NVIDIA_BUILD_ID=${CI_PIPELINE_ID}"
                   --build-arg "PYVER=${PYVER}" --build-arg "PYV=${PYV}"
                   --label "com.nvidia.build.id=${CI_JOB_ID}"
                   -f Dockerfile.base .
    - docker push "${BASE_IMAGE_NAME}"
    - docker push "${BASE_IMAGE_NAME_VERSIONED}"
    except:
    - tags

py27-base:
  <<: *BASE

#py34-base:
#  <<: *BASE

py35-base:
  <<: *BASE

#py36-base:
#  <<: *BASE

#py37-base:
#  <<: *BASE

.devel_template: &DEVEL
    stage: build devel
    variables:
      GIT_STRATEGY: fetch
      GIT_SUBMODULE_STRATEGY: recursive
      GET_SOURCES_ATTEMPTS: 3
    script:
    - export CI_PROJECT_NAME=dali
    - echo -e "FROM ${BASE_IMAGE_NAME_VERSIONED}\n"
              "COPY CMakeLists.txt /opt/${CI_PROJECT_NAME}/\n"
              "COPY Dockerfile* /opt/${CI_PROJECT_NAME}/\n"
              "COPY .gitignore /opt/${CI_PROJECT_NAME}/\n"
              "COPY .gitmodules /opt/${CI_PROJECT_NAME}/\n"
              "COPY .gitlab-ci.yml /opt/${CI_PROJECT_NAME}/\n"
              "COPY .git/ /opt/${CI_PROJECT_NAME}/.git/\n"
              "COPY cmake/   /opt/${CI_PROJECT_NAME}/cmake/\n"
              "COPY dali/ /opt/${CI_PROJECT_NAME}/dali/\n"
              "COPY qa/   /opt/${CI_PROJECT_NAME}/qa/\n"
              "COPY third_party/  /opt/${CI_PROJECT_NAME}/third_party/\n"
        > Dockerfile.${CI_PROJECT_NAME}.${CI_COMMIT_REF_NAME}
    - git remote set-url origin ${ORIGIN_HTTPS}
    - docker build --pull -t "${DEVEL_IMAGE_NAME}" -t "${DEVEL_IMAGE_NAME_VERSIONED}"
                   -f Dockerfile.${CI_PROJECT_NAME}.${CI_COMMIT_REF_NAME} .
    - docker push "${DEVEL_IMAGE_NAME}"
    - docker push "${DEVEL_IMAGE_NAME_VERSIONED}"
    except:
    - tags

py27-dali:
  <<: *DEVEL

#py34-dali:
#  <<: *DEVEL

py35-dali:
  <<: *DEVEL

#py36-dali:
#  <<: *DEVEL

#py37-dali:
#  <<: *DEVEL

.docs_template: &DOCS_BUILD
    stage: build docs
    variables:
      GIT_STRATEGY: fetch
      GIT_SUBMODULE_STRATEGY: recursive
      GET_SOURCES_ATTEMPTS: 3
    script:
    - export CI_PROJECT_NAME=dali
    - export CONTAINER_NAME="${CI_PROJECT_NAME}.${CI_JOB_ID}.${CI_JOB_NAME}"
    - docker pull "$BASE_IMAGE_NAME}" || true
    - docker build -t ${DOCS_IMAGE_NAME}
                   --build-arg "BASE_IMAGE_NAME=${BASE_IMAGE_NAME_VERSIONED}"
                   --build-arg "GIT_SHA=${GIT_SHA}"
                   -f Dockerfile.docs .
    - docker run $(eval ${NV_DOCKER_ARGS})
             --name "${CONTAINER_NAME}"
             -v $DATADIR:/data
             $(eval echo ${EXTRA_DOCKER_RUN_ARGS})
             $(eval echo ${DOCS_IMAGE_NAME})
             /bin/bash -c "make html" || RV=$?;
    - docker cp "${CONTAINER_NAME}:/opt/dali/docs/_build/html/" "html/"
    - docker rm -f ${CONTAINER_NAME}
    - docker rmi ${DOCS_IMAGE_NAME}
    artifacts:
      name: "${CI_JOB_NAME}"
      paths:
      - html/
      expire_in: 1 month
    except:
    - tags
    tags:
    - 1GPU

py35-docs:
   <<: *DOCS_BUILD

.test_template: &TEST_TEMPLATE
    environment: "${CI_JOB_NAME}"
    variables:
      TEST_WORK_DIR: "/opt/dali/qa/${CI_JOB_NAME}/"
      TEST_SCRIPT: "./test.sh"
      TEST_IMAGE: "$${DEVEL_IMAGE_NAME_VERSIONED}"
    script:
    - export TEST_WORK_DIR="${TEST_WORK_DIR%%--*}"
    - export CONTAINER_NAME="${CI_PROJECT_NAME}.${CI_JOB_ID}.${CI_JOB_NAME}"
    - cat /proc/driver/nvidia/version
    - docker pull $(eval echo ${TEST_IMAGE})
    - ( sleep 10800 && echo "******TIMEOUT EXPIRED******" && docker kill "${CONTAINER_NAME}" ) &
      set -x &&
      docker run --rm $(eval ${NV_DOCKER_ARGS})
             --name "${CONTAINER_NAME}"
             -v $DATADIR:/data
             $(eval echo ${EXTRA_DOCKER_RUN_ARGS})
             $(eval echo ${TEST_IMAGE})
             /bin/bash -c "nvidia-smi && cd ${TEST_WORK_DIR} && exec bash -ex ${TEST_SCRIPT}" || RV=$?;
      set +x;
      pkill -HUP sleep || true;
      exit ${RV:-0}
    tags:
    - must_specify_runner
    except:
    - tags
    allow_failure: false

# TODO : deduplicate w/ above
.CPU_ONLY_TEST: &CPU_ONLY_TEST
    variables:
#      TEST_WORK_DIR: "/opt/${CI_PROJECT_NAME}/qa/${CI_JOB_NAME}/"
      TEST_WORK_DIR: "/opt/dali/qa/${CI_JOB_NAME}/"
      TEST_SCRIPT: "./test.sh"
      TEST_IMAGE: "$${BUILD_IMAGE_NAME_VERSIONED}"
    script:
    - export TEST_WORK_DIR="${TEST_WORK_DIR%%--*}"
    - export CONTAINER_NAME="${CI_PROJECT_NAME}.${CI_JOB_ID}.${CI_JOB_NAME}"
    - docker pull $(eval echo ${TEST_IMAGE})
    - ( sleep 10800 && echo "******TIMEOUT EXPIRED******" && docker kill "${CONTAINER_NAME}" ) &
      set -x &&
      docker run --rm $(eval ${NV_DOCKER_ARGS})
             --name "${CONTAINER_NAME}"
             -v $DATADIR:/data
             $(eval echo ${EXTRA_DOCKER_RUN_ARGS})
             $(eval echo ${TEST_IMAGE})
             /bin/bash -c "cd ${TEST_WORK_DIR} && exec bash -ex ${TEST_SCRIPT}" || RV=$?;
      set +x;
      pkill -HUP sleep || true;
      exit ${RV:-0}
    tags:
    - 1GPU

.manual_test_trigger: &MANUAL_TEST_TRIGGER
    stage: trigger
    script:
    - export SCOPE1=${CI_JOB_NAME%% tests}; export SCOPE=${SCOPE1##Run all }
    - docker pull ${CI_REGISTRY}/devops/scripts:nvdl_nightly_test_scheduler
    - docker run --rm ${CI_REGISTRY}/devops/scripts:nvdl_nightly_test_scheduler ${CI_PIPELINE_ID} ${CI_PROJECT_PATH} ${SCOPE}
    except:
    - tags
    when: manual

.L0_test: &L0_TEST
    stage: test
    <<: *TEST_TEMPLATE

.L1_test: &L1_TEST
    stage: test
    <<: *TEST_TEMPLATE
    when: manual
    allow_failure: true

.P100_R384_4GPU: &P100_R384_4GPU
    tags:
    - P100
    - R384
    - 4GPU

.V100_R384_4GPU: &V100_R384_4GPU
    tags:
    - V100
    - R384
    - 4GPU
.V100_R384_1GPU: &V100_R384_1GPU
    tags:
    - V100
    - R384
    - 1GPU
.V100_R384_8GPU: &V100_R384_8GPU
    tags:
    - V100
    - R384
    - 8GPU

######################################################
##
## Test definitions.
##
##   By convention, test names should be prefixed
##   with "L0_" or "L1_" etc.
##
##   Normally qa/ will be a submodule that pulls in
##   all of the stuff needed to run the tests into the
##   *-devel images.
##
##   The CI script templates above expect each test to
##   be defined in /opt/<project>/qa/<testname>/test.sh.
##   This behavior is specified by the variables
##   $TEST_WORK_DIR and $TEST_SCRIPT.  You can override
##   either of those variables for a given test, but if
##   you do, you have to override them both together,
##   like this:
##
##   L0_mytest:
##      <<: *L0_TEST
##      variables:
##        TEST_WORK_DIR: "/some/other/path"
##        TEST_SCRIPT: "./test.sh"
##
######################################################


L0_lint--py27:
  <<: *L0_TEST
  <<: *CPU_ONLY_TEST

L0_self-test--py35--P100_R384_4GPU:
  <<: *L0_TEST
  <<: *P100_R384_4GPU

L0_python-self-test--py27--P100_R384_4GPU:
  <<: *L0_TEST
  <<: *P100_R384_4GPU

L0_python-self-test--py35--P100_R384_4GPU:
  <<: *L0_TEST
  <<: *P100_R384_4GPU

L0_rn50-benchmarks--py35--P100_R384_4GPU:
  <<: *L0_TEST
  <<: *P100_R384_4GPU

L0_rn50_python-benchmarks--py35--P100_R384_4GPU:
  <<: *L0_TEST
  <<: *P100_R384_4GPU

L0_rn50_python-benchmarks--py27--P100_R384_4GPU:
  <<: *L0_TEST
  <<: *P100_R384_4GPU

L0_framework_imports--py27--P100_R384_4GPU:
  <<: *L0_TEST
  <<: *P100_R384_4GPU

L0_framework_imports--py35--P100_R384_4GPU:
  <<: *L0_TEST
  <<: *P100_R384_4GPU

L0_framework_imports--py27--V100_R384_1GPU:
  <<: *L0_TEST
  <<: *V100_R384_1GPU

L0_framework_imports--py35--V100_R384_1GPU:
  <<: *L0_TEST
  <<: *V100_R384_1GPU

L0_self-test--py35--V100_R384_1GPU:
  <<: *L0_TEST
  <<: *V100_R384_1GPU

L0_python-self-test--py27--V100_R384_1GPU:
  <<: *L0_TEST
  <<: *V100_R384_1GPU

L0_python-self-test--py35--V100_R384_1GPU:
  <<: *L0_TEST
  <<: *V100_R384_1GPU

L0_rn50-benchmarks--py35--V100_R384_1GPU:
  <<: *L0_TEST
  <<: *V100_R384_1GPU

L0_rn50_python-benchmarks--py35--V100_R384_1GPU:
  <<: *L0_TEST
  <<: *V100_R384_1GPU

L0_rn50_python-benchmarks--py27--V100_R384_1GPU:
  <<: *L0_TEST
  <<: *V100_R384_1GPU

L0_jupyter--py27--P100_R384_4GPU:
  <<: *L0_TEST
  <<: *P100_R384_4GPU

L0_jupyter--py27--V100_R384_1GPU:
  <<: *L0_TEST
  <<: *V100_R384_1GPU

L1_jupyter_plugins--py27--V100_R384_8GPU:
  <<: *L1_TEST
  <<: *V100_R384_8GPU
